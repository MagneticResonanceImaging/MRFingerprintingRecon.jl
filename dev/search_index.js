var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRFingerprintingRecon.jl package:\n\n","category":"section"},{"location":"api/#MRFingerprintingRecon.FFTNormalOp-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.FFTNormalOp","text":"FFTNormalOp(img_shape, trj, U; cmaps)\nFFTNormalOp(M, U; cmaps)\nFFTNormalOp(Λ; cmaps, eltype_x)\n\nCreate normal operator of FFT operator. Differentiate between functions exploiting a pre-calculated kernel basis Λ and the functions which calculate Λ based on a passed trajectory trj or mask M.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntraj::Vector{Matrix}: Trajectory\nU::Matrix: Basis coefficients of subspace\ncmaps::Matrix=(1,): Coil sensitivities\nsample_mask::AbstractArray{Bool}=trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are retained for reconstruction\nM::Vector{Matrix}: Mask\nΛ::Array{Complex{T},3}: Toeplitz kernel basis\nnum_fft_threads::Int=round(Int, Threads.nthreads()/size(U, 2)) or `round(Int, Threads.nthreads()/size(Λ, 1)): Number of Threads for FFT\neltype_x=eltype(Λ) define the type of x (in the product FFTNormalOp(Λ) * x). The default is the same eltype as Λ\n\nReferences\n\nTamir JI, et al. “T2 shuffling: Sharp, multicontrast, volumetric fast spin-echo imaging”. Magn Reson Med. 77.1 (2017), pp. 180–195. https://doi.org/10.1002/mrm.26102\nAssländer J, et al. “Low rank alternating direction method of multipliers reconstruction for MR fingerprinting”. Magn Reson Med 79.1 (2018), pp. 83–96. https://doi.org/10.1002/mrm.26639\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.NFFTNormalOp-Union{Tuple{Tc}, Tuple{T}, Tuple{Any, AbstractArray{T, 3}, AbstractArray{Tc}}} where {T<:Real, Tc<:Union{Complex{T}, T}}","page":"API","title":"MRFingerprintingRecon.NFFTNormalOp","text":"NFFTNormalOp(img_shape, trj, U; cmaps, sample_mask, verbose, num_fft_threads)\nNFFTNormalOp(img_shape, Λ, kmask_indcs; cmaps)\n\nCreate normal operator of NFFT operator. Differentiate between functions exploiting a pre-calculated Toeplitz kernel basis Λ and the function which calculates Λ based on a passed trajectory trj. When the basis functions U are real-valued, a real-only NUFFT is used to compute Λ, reducing the data volume for the spreading and interpolation steps by half.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntrj::AbstractArray: Trajectory, use CuArray as input type to use CUDA code.\nU::AbstractMatrix: Basis coefficients of subspace\ncmaps::AbstractVector{Matrix}=(1,): Coil sensitivities, use AbstractVector{CuArray} as type for use with CUDA code.\nsample_mask::AbstractArray{Bool} = trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are retained for reconstruction\nverbose::Boolean=false: Verbose level\nnum_fft_threads::Int=round(Int, Threads.nthreads()/size(U, 2)) or round(Int, Threads.nthreads()/size(Λ, 1)): Number of threads for FFT\n\nReferences\n\nWajer FTAW, and Pruessmann, KP. “Major Speedup of Reconstruction for Sensitivity Encoding with Arbitrary Trajectories”. In: Proc. Intl. Soc. Mag. Reson. Med 9 (2001).\nFessler JA, et al. \"Toeplitz-Based Iterative Image Reconstruction for MRI With Correction for Magnetic Field Inhomogeneity\". IEEE Trans. Signal Process., 53.9 (2006).\nMani M, et al. “Fast iterative algorithm for the reconstruction of multishot non-cartesian diffusion data”. Magn Reson Med. 74.4 (2015), pp. 1086–1094. https://doi.org/10.1002/mrm.25486\nUecker M, Zhang S, and Frahm J. “Nonlinear inverse reconstruction for real-time MRI of the human heart using undersampled radial FLASH\". Magn Res Med. 63 (2010), pp. 1456–1462. https://doi.org/10.1002/mrm.22453\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculateGoldenMeans-Tuple{}","page":"API","title":"MRFingerprintingRecon.calculateGoldenMeans","text":"calculateGoldenMeans()\n\nFunction to calculate 3D golden means [1].\n\nReferences\n\nChan RW, Ramsay EA, Cunningham CH, and Plewes DB. \"Temporal stability of adaptive 3D radial MRI using multidimensional golden means\". Magn. Reson. Med. (2009), 61: 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculate_backprojection-Union{Tuple{Tc}, Tuple{T}, Tuple{AbstractArray{Tc, 3}, AbstractArray{T, 3}, Any}} where {T<:Real, Tc<:Complex{T}}","page":"API","title":"MRFingerprintingRecon.calculate_backprojection","text":"calculate_backprojection(data, trj, img_shape; U, sample_mask, density_compensation, verbose)\ncalculate_backprojection(data, trj, cmaps::AbstractVector{<:AbstractArray{Tc,N}}; U, sample_mask, density_compensation, verbose)\ncalculate_backprojection(data, trj, cmaps_img_shape; U, sample_mask, density_compensation, verbose)\ncalculate_backprojection(data, trj, cmaps; U, sample_mask)\n\nCalculate (filtered) backprojection.\n\nArguments\n\ndata <: AbstractArray{Complex}: Complex dataset with axes (samples, time frames, channels). Time frames are reconstructed using the subspace defined in U. Use CuArray as input type to use CUDA GPU code.\ntrj <: AbstractArray: Trajectory with sample coordinates corresponding to the dataset. For a Cartesian reconstruction, use T <: Int and define trj[idim,it,ik] ∈ (1, img_shape[idim]). If T <: Float, the NFFT is used. Use CuArray as input type to use CUDA code.\n\nOne of the following arguments needs to be supplied\n\nimg_shape::NTuple{N,Int}: Shape of image; in this case, the data is reconstructed per coil.\ncmaps::AbstractVector{<:AbstractArray{Tc}}: Coil sensitivities; in this case, the coils are added up to a single backprojection. Use AbstractVector{CuArray{Tc,N}} as type for use with CUDA code.\n\nOptional Keyword Arguments\n\nU::Matrix=I(size(trj)[end]) or =I(1): Basis coefficients of subspace (only defined if data and trj have different timeframes)\nsample_mask::AbstractArray{Bool}=trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are retained for reconstruction\ndensity_compensation=:none: Values of :radial_3D, :radial_2D, :none, or of type AbstractVector{<:AbstractVector}\nverbose::Boolean=false: Verbosity level\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculate_coil_maps-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{Complex{T}}, AbstractArray{T}, NTuple{N, Int64}}} where {N, T}","page":"API","title":"MRFingerprintingRecon.calculate_coil_maps","text":"calculate_coil_maps(data, trj, img_shape; U, density_compensation, kernel_size, calib_size, eigThresh_1, eigThresh_2, nmaps, verbose)\n\nEstimate coil sensitivity maps using ESPIRiT [1].\n\nArguments\n\ndata::AbstractArray: Complex dataset with axes (samples, time frames, channels). Time frames are reconstructed using the subspace defined in U. Use CuArray as input type to use CUDA code.\ntrj::AbstractArray: Trajectory with sample coordinates corresponding to the dataset Use CuArray as input type to use GPU code.\nimg_shape::NTuple{N,Int}: Shape of image\n\nKeyword Arguments\n\nU::Matrix=ones(size(trj)[end]) : I(1): Basis coefficients of subspace\nsample_mask::AbstractArray{Bool}=trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are retained for reconstruction\ndensity_compensation=:radial_3D: Values of :radial_3D, :radial_2D, :none, or of type  AbstractArray\nkernel_size=ntuple(_ -> 6, N): Kernel size\ncalib_size=ntuple(_ -> 24, N): Size of calibration region\neigThresh_1=0.01: Threshold of first eigenvalue\neigThresh_2=0.9: Threshold of second eigenvalue\nnmaps=1: Number of estimated maps\nNiter_cg: Number of CG iterations used for the reconstruction. The default is 100 for non-Cartesian and 5 for Cartesian trajectories.\nverbose::Boolean=false: Verbosity level\n\nReturn\n\ncmaps::Vector{Array}: Coil sensitivities as Vector of arrays\n\nReferences\n\nUecker M, Lai P, Murphy MJ, Virtue P, Elad M, Pauly JM, Vasanawala SS, and Lustig M. \"ESPIRiT—an eigenvalue approach to autocalibrating parallel MRI: Where SENSE meets GRAPPA\". Magn. Reson. Med. 71 (2014), pp. 990-1001. https://doi.org/10.1002/mrm.24751\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.grog_calib-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.grog_calib","text":"grog_calib(data, trj, Nr)\n\nPerform GROG kernel calibration based on whole radial trajectory and passed data. Calibration follows the work on self-calibrating radial GROG (https://doi.org/10.1002/mrm.21565).\n\nArguments\n\ndata::AbstractAbstractArray: Complex dataset with dimensions (samples per time frame [Nr], time frames, Rx channels)\ntrj::AbstractArray: Trajectory with samples corresponding to the dataset, passed as AbstractArray with dimension (dims, samples per time frame, time frames)\nNr::Int: Number of samples per read out\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.grog_gridding!-NTuple{5, Any}","page":"API","title":"MRFingerprintingRecon.grog_gridding!","text":"grog_gridding!(data, trj, lnG, Nr, img_shape)\n\nPerform gridding of data based on pre-calculated GROG kernel.\n\nArguments\n\ndata::AbstractVector{<:AbstractMatrix}: Complex dataset passed as AbstractVector of matrices\ntrj::AbstractArray}: Trajectory with samples corresponding to the dataset passed as AbstractVector of matrices with Float32 entries\nlnG::AbstractArray{Matrix}: Natural logarithm of GROG kernel in all dimensions\nNr::Int: Number of samples per read out\nimg_shape::Tuple{<:Integer}: Image dimensions\n\nOutput\n\ntrj::AbstractArray{<:Integer}: Cartesian trajectory with the elements trj[idim,ik,it] ∈ (1, img_shape[idim])\n\nDimensions:\n\ndata:   (samples, timesteps, coils, repetitions of sampling pattern)\ntrj:    (dims, samples, timesteps)\nlnG:    (dims][Ncoils, Ncoils)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.radial_grog!-NTuple{4, Any}","page":"API","title":"MRFingerprintingRecon.radial_grog!","text":"radial_grog!(data, trj, Nr, img_shape)\n\nPerform GROG kernel calibration and gridding [1] of data in-place. The trajectory is returned with integer values.\n\nArguments\n\ndata::AbstractArray}: Complex dataset with dimensions (samples per time frame [Nr], time frames, Rx channels)\ntrj::AbstractArray: Trajectory with samples corresponding to the dataset, passed as AbstractArray with dimension (dims, samples per time frame, time frames)\nNr::Int: Number of samples per read out\nimg_shape::Tuple{Int}: Image dimensions\n\nOutput\n\ntrj::AbstractArray{<:Integer}}: Cartesian trajectory with the elements trj[idim,ik,it] ∈ (1, img_shape[idim])\n\nReferences\n\nSeiberlich N, Breuer F, Blaimer M, Jakob P, and Griswold M. \"Self-calibrating GRAPPA operator gridding for radial and spiral trajectories\". Magn. Reson. Med. 59 (2008), pp. 930-935. https://doi.org/10.1002/mrm.21565\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_2d_radial_goldenratio-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.traj_2d_radial_goldenratio","text":"traj_2d_radial_goldenratio(Nr, Ncyc, Nt; thetaRot, phiRot, delay, N)\n\nFunction to calculate 2D golden ratio based trajectory [1]. By modifying N also tiny golden angles [2] are supported.\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float} = (0, 0, 0): Gradient delays in (HF, AP, LR)\nN::Int = 1: Number of tiny golden angle\n\nReferences\n\nWinkelmann S, Schaeffter T, Koehler T, Eggers H, Doessel O. \"An optimal radial profile order based on the Golden Ratio for time-resolved MRI\". IEEE TMI 26:68-76 (2007)\nWundrak S, Paul J, Ulrici J, Hell E, Geibel MA, Bernhardt P, Rottbauer W, Rasche V. \"Golden ratio sparse MRI using tiny golden angles\". Magn. Reson. Med. 75:2372-2378 (2016)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_cartesian-NTuple{4, Any}","page":"API","title":"MRFingerprintingRecon.traj_cartesian","text":"traj_cartesian(T, Nx, Ny, Nz, Nt)\n\nGenerate a 3D Cartesian trajectory.\n\nArguments\n\nNx::Int: Number of readout samples\nNy::Int: Number of phase encoding lines\nNz::Int: Number of phase encoding lines (third dimension)\nNt::Int: Number of time steps in the trajectory\n\nOptional Keyword Argument\n\nT::Type=Int: Type of output trajectory. If T <: Float, trajectory is defined ∈ (-0.5, 0.5). If T <: Int, trajectory consists of values ∈ (1, N) instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_kooshball-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.traj_kooshball","text":"traj_kooshball(Nr, theta, phi; thetaRot, phiRot, delay)\n\nFunction to calculate traj_kooshball trajectory.\n\nArguments\n\nNr::Int: Number of read out samples\ntheta::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles theta for each cycle and time step.\nphi::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles phi for each cycle and time step.\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float} = (0, 0, 0): Gradient delays in (HF, AP, LR)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_kooshball_goldenratio-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.traj_kooshball_goldenratio","text":"traj_kooshball_goldenratio(Nr, Ncyc, Nt; thetaRot, phiRot, delay)\n\nFunction to calculate  golden means [1] based traj_kooshball trajectory.\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float}= (0, 0, 0): Gradient delays in (HF, AP, LR)\n\nReferences\n\nChan RW, Ramsay EA, Cunningham CH, and Plewes DB. \"Temporal stability of adaptive 3D radial MRI using multidimensional golden means\". Magn. Reson. Med. 61 (2009) pp. 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"section"},{"location":"build_literate/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"TODO\n\nFor this example, we need the following packages:\n\nusing MRFingerprintingRecon\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#MRFingerprintingRecon.jl","page":"Home","title":"MRFingerprintingRecon.jl","text":"Documentation for the MRFingerprintingRecon.jl package. Stay tuned for the documentation...\n\nThe documentation of all exported functions can be found in the API Section.","category":"section"}]
}
