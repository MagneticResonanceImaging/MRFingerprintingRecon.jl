var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Author = \"Jakob Assländer\"\nCurrentModule = MRFingerprintingRecon","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRFingerprintingRecon.jl package:","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MRFingerprintingRecon]","category":"page"},{"location":"api/#MRFingerprintingRecon.FFTNormalOp-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.FFTNormalOp","text":"FFTNormalOp(img_shape, trj, U; cmaps)\nFFTNormalOp(M, U; cmaps)\nFFTNormalOp(Λ; cmaps)\n\nCreate normal operator of FFT operator. Differentiate between functions exploiting a pre-calculated kernel basis Λ and the functions which calculate Λ based on a passed trajectory trj or mask M.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntraj::Vector{Matrix{Float32}}: Trajectory\nU::Matrix{ComplexF32}: Basis coefficients of subspace\ncmaps::Matrix{ComplexF32}: Coil sensitivities\nM::Vector{Matrix{Float32}}: Mask\nΛ::Array{Complex{T},3}: Toeplitz kernel basis\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.NFFTNormalOp-Union{Tuple{Tc}, Tuple{T}, Tuple{Any, AbstractVector{<:AbstractMatrix{T}}, AbstractMatrix{Tc}}} where {T, Tc<:Union{Complex{T}, T}}","page":"API","title":"MRFingerprintingRecon.NFFTNormalOp","text":"NFFTNormalOp(img_shape, trj, U; cmaps, verbose, num_fft_threads)\nNFFTNormalOp(img_shape, Λ, kmask_indcs; cmaps)\n\nCreate normal operator of NFFT operator. Differentiate between functions exploiting a pre-calculated Toeplitz kernel basis Λ and the function which calculates Λ based on a passed trajectory trj.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntraj::Vector{Matrix{Float32}}: Trajectory\nU::Matrix{ComplexF32}: Basis coefficients of subspace\ncmaps::Matrix{ComplexF32}: Coil sensitivities\nΛ::Array{Complex{T},3}: Toeplitz kernel basis\nkmask_indcs::Vector{Int}: Sampling indices of Toeplitz mask\nverbose::Boolean: Verbose level\nnum_fft_threads::Int: Number of threads for FFT\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculateBackProjection-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{T}, Any, Tuple{Vararg{Int64, N}}}} where {N, T}","page":"API","title":"MRFingerprintingRecon.calculateBackProjection","text":"calculateBackProjection(data, trj, img_shape; U, density_compensation, verbose)\ncalculateBackProjection(data, trj, cmaps; U, density_compensation, verbose)\n\nCalculate backprojection\n\nArguments\n\ndata::AbstractArray{T}: Basis coefficients of subspace\ntrj::Vector{Matrix{Float32}}: Trajectory\nimg_shape::NTuple{N,Int}: Shape of image\nU::Matrix{ComplexF32}: Basis coefficients of subspace\ndensity_compensation: Values of :radial_3D, :radial_2D, :none, or of type  AbstractVector{<:AbstractVector}`\nverbose::Boolean: Verbosity level\ncmaps::::AbstractVector{<:AbstractArray{T}}: Coil sensitivities\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculateBackProjection_gridded-NTuple{4, Any}","page":"API","title":"MRFingerprintingRecon.calculateBackProjection_gridded","text":"calculateBackProjection_gridded(data, trj, U, cmaps)\n\nCalculate gridded backprojection\n\nArguments\n\ndata::Matrix{ComplexF32}: Basis coefficients of subspace\ntrj::Vector{Matrix{Float32}}: Trajectory\nU::Matrix{ComplexF32}: Basis coefficients of subspace\ncmaps::Matrix{ComplexF32}: Coil sensitivities\n\nNote\n\nIn case of repeated sampling (Nrep > 1), a joint basis reconstruction is required. Therefore, the basis needs to have a temporal dimension of Nt⋅Nrep with Nt as time dimension defined by the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculateGoldenMeans-Tuple{}","page":"API","title":"MRFingerprintingRecon.calculateGoldenMeans","text":"calculateGoldenMeans()\n\nFunction to calculate 3D golden means [1].\n\nReferences\n\n[1] Chan, R.W., Ramsay, E.A., Cunningham, C.H. and Plewes, D.B. (2009), Temporal stability of adaptive 3D radial MRI using multidimensional golden means. Magn. Reson. Med., 61: 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.grog_calib-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.grog_calib","text":"grog_calib(data, trj, Nr)\n\nPerform GROG kernel calibration based on whole radial trajectory and passed data. Calibration follows the work on self-calibrating radial GROG (https://doi.org/10.1002/mrm.21565).\n\nArguments\n\ndata::Matrix{ComplexF32}: Basis coefficients of subspace\ntraj::Vector{Matrix{Float32}}: Trajectory\nNr::Int: Number of samples per read out\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.grog_gridding!-NTuple{5, Any}","page":"API","title":"MRFingerprintingRecon.grog_gridding!","text":"grog_gridding!(data, trj, lnG, Nr, img_shape)\n\nPerform gridding of data based on pre-calculated GROG kernel.\n\nArguments\n\ndata::Matrix{ComplexF32}: Basis coefficients of subspace\ntraj::Vector{Matrix{Float32}}: Trajectory\nlnG::Vector{Matrix{Float32}}: Natural logarithm of GROG kernel in all dimensions\nNr::Int: Number of samples per read out\nimg_shape::Tuple{Int}: Image dimensions\n\nDimensions:\n\ndata:   [samples, spokes, timesteps, coils, repetitions of sampling pattern]\ntrj:    [timesteps, repetitions][dims, samples]\nlnG:    [dims][Ncoils, Ncoils]\n\nFurther:\n\nEnsure sampling pattern repeats in repetitions dimension!\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.kooshball-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.kooshball","text":"kooshball(Nr, theta, phi; thetaRot = 0, phiRot = 0, delay = (0, 0, 0), T = Float32)\n\nFunction to calculate kooshball trajectory.\n\nArguments\n\nNr::Int: Number of read out samples\ntheta::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles theta for each cycle and timestep.\nphi::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles phi for each cycle and timestep.\nthetaRot::Float: Fixed rotation angle along theta\nphiRot::Float: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float}: Gradient delays in (HF, AP, LR)\nT::Type: Type defining the output units of the trajectory\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.kooshballGA-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.kooshballGA","text":"kooshballGA(Nr, Ncyc, Nt; thetaRot = 0, phiRot = 0, delay = (0, 0, 0), T = Float32)\n\nFunction to calculate  golden means [1] based kooshball trajectory.\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float: Fixed rotation angle along theta\nphiRot::Float: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float}: Gradient delays in (HF, AP, LR)\nT::Type: Type defining the output units of the trajectory\n\nReferences\n\n[1] Chan, R.W., Ramsay, E.A., Cunningham, C.H. and Plewes, D.B. (2009), Temporal stability of adaptive 3D radial MRI using multidimensional golden means. Magn. Reson. Med., 61: 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.radial_grog!-NTuple{4, Any}","page":"API","title":"MRFingerprintingRecon.radial_grog!","text":"radial_grog!(data, trj, Nr, img_shape)\n\nPerform GROG kernel calibration and gridding of data in-place.\n\nArguments\n\ndata::Matrix{ComplexF32}: Basis coefficients of subspace\ntraj::Vector{Matrix{Float32}}: Trajectory\nNr::Int: Number of samples per read out\nimg_shape::Tuple{Int}: Image dimensions\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_2d_cartesian-NTuple{4, Any}","page":"API","title":"MRFingerprintingRecon.traj_2d_cartesian","text":"traj_2d_cartesian(Nx, Ny, Nz, Nt; samplingRate_units = true, T = Float32)\n\nFunction to calculate a 2D cartesian trajectory in units of sampling rate ∈ {x | -N/2+1 ≤ x ≤ N/2 and x ∈ Z}. With samplingRate_units = false the ouput is relative with samples ∈ [-1/2:1/2].\n\nArguments\n\nNx::Int: Number of frequency encoded samples per read out\nNy::Int: Number of phase encoding lines\nNz::Int: Number of phase encoding lines (third dimension)\nNt::Int: Number of times the sampling pattern is repeated\nsamplingRate_units::Boolean: Parameter setting the output units to sampling rate\nT::Type: Type defining the output units of the trajectory\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_2d_radial_goldenratio-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.traj_2d_radial_goldenratio","text":"traj_2d_radial_goldenratio(Nr, Ncyc, Nt; thetaRot = 0, phiRot = 0, delay = (0, 0, 0), N = 1, T = Float32)\n\nFunction to calculate 2D golden ratio based trajectory [1]. By modifying N also tiny golden angles [2] are supported.\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float: Fixed rotation angle along theta\nphiRot::Float: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float}: Gradient delays in (HF, AP, LR)\nN::Int: Number of tiny golden angle\nT::Type: Type defining the output units of the trajectory\n\nReferences\n\n[1] Winkelmann S, Schaeffter T, Koehler T, Eggers H, Doessel O. An optimal radial profile order based on the Golden Ratio for time-resolved MRI. IEEE TMI 26:68–76 (2007) [2] Wundrak S, Paul J, Ulrici J, Hell E, Geibel MA, Bernhardt P, Rottbauer W, Rasche V. Golden ratio sparse MRI using tiny golden angles. Magn Reson Med 75:2372-2378 (2016)\n\n\n\n\n\n","category":"method"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../tutorial.jl\"","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"TODO","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"For this example, we need the following packages:","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"using MRFingerprintingRecon\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRFingerprintingRecon","category":"page"},{"location":"#MRFingerprintingRecon.jl","page":"Home","title":"MRFingerprintingRecon.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the MRFingerprintingRecon.jl package. Stay tuned for the documentation...","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation of all exported functions can be found in the API Section.","category":"page"}]
}
