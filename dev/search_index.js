var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRFingerprintingRecon.jl package:","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#MRFingerprintingRecon.FFTNormalOp-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.FFTNormalOp","text":"FFTNormalOp(img_shape, trj, U; cmaps)\nFFTNormalOp(M, U; cmaps)\nFFTNormalOp(Λ; cmaps, eltype_x)\n\nCreate normal operator of FFT operator. Differentiate between functions exploiting a pre-calculated kernel basis Λ and the functions which calculate Λ based on a passed trajectory trj or mask M.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntraj::Vector{Matrix{Float32}}: Trajectory\nU::Matrix{ComplexF32}=(1,): Basis coefficients of subspace\ncmaps::Matrix{ComplexF32}: Coil sensitivities\nM::Vector{Matrix{Float32}}: Mask\nΛ::Array{Complex{T},3}: Toeplitz kernel basis\nnum_fft_threads::Int = round(Int, Threads.nthreads()/size(U, 2)) or `round(Int, Threads.nthreads()/size(Λ, 1)): Number of Threads for FFT\neltype_x=eltype(Λ) define the type of x (in the product FFTNormalOp(Λ) * x). The default is the same eltype as Λ\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.NFFTNormalOp-Union{Tuple{Tc}, Tuple{T}, Tuple{Any, AbstractVector{<:AbstractMatrix{T}}, AbstractArray{Tc}}} where {T, Tc<:Union{Complex{T}, T}}","page":"API","title":"MRFingerprintingRecon.NFFTNormalOp","text":"NFFTNormalOp(img_shape, trj, U; cmaps, verbose, num_fft_threads)\nNFFTNormalOp(img_shape, Λ, kmask_indcs; cmaps)\n\nCreate normal operator of NFFT operator. Differentiate between functions exploiting a pre-calculated Toeplitz kernel basis Λ and the function which calculates Λ based on a passed trajectory trj.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntraj::AbstractVector{<:AbstractMatrix{T}}: Trajectory\nU::AbstractMatrix{Tc}: Basis coefficients of subspace\ncmaps::AbstractVector{Matrix{ComplexF32}}=[ones(T, img_shape)]: Coil sensitivities\nΛ::Array{Complex{T},3}: Toeplitz kernel basis\nkmask_indcs::Vector{Int}: Sampling indices of Toeplitz mask\nverbose::Boolean=false: Verbose level\nnum_fft_threads::Int=round(Int, Threads.nthreads()/size(U, 2)) or round(Int, Threads.nthreads()/size(Λ, 1)): Number of threads for FFT\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calcCoilMaps-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{<:AbstractArray{Complex{T}, 2}}, AbstractVector{<:AbstractMatrix{T}}, NTuple{N, Int64}}} where {N, T}","page":"API","title":"MRFingerprintingRecon.calcCoilMaps","text":"calcCoilMaps(data, trj, img_shape; U, density_compensation, kernel_size, calib_size, eigThresh_1, eigThresh_2, nmaps, verbose)\n\nEstimate coil sensitivity maps using ESPIRiT [1].\n\nArguments\n\ndata::AbstractVector{<:AbstractMatrix{Complex{T}}}: Complex dataset either as AbstractVector of matrices or single matrix. The optional outer vector defines different time frames that are combined using the subspace defined in U\ntrj::AbstractVector{<:AbstractMatrix{T}}: Trajectory with samples corresponding to the dataset either as AbstractVector of matrices or single matrix.\nimg_shape::NTuple{N,Int}: Shape of image\n\nKeyword Arguments\n\nU::Matrix = N==3 ? ones(size(data,1)) : I(1): Basis coefficients of subspace (only defined if data and trj are vectors of matrices)\ndensity_compensation=:radial_3D: Values of :radial_3D, :radial_2D, :none, or of type  AbstractVector{<:AbstractVector}\nkernel_size=ntuple(_ -> 6, N): Kernel size\ncalib_size=ntuple(_ -> 24, N): Size of calibration region\neigThresh_1=0.01: Threshold of first eigenvalue\neigThresh_2=0.9: Threshold of second eigenvalue\nnmaps=1: Number of estimated maps\nverbose::Boolean=false: Verbosity level\n\nreturn\n\ncmaps::::Vector{<:Array{Complex{T}}}: Coil sensitivities as Vector of arrays\n\nReferences\n\n[1] Uecker, M., Lai, P., Murphy, M.J., Virtue, P., Elad, M., Pauly, J.M., Vasanawala, S.S. and Lustig, M. (2014), ESPIRiT—an eigenvalue approach to autocalibrating parallel MRI: Where SENSE meets GRAPPA. Magn. Reson. Med., 71: 990-1001. https://doi.org/10.1002/mrm.24751\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculateBackProjection-Union{Tuple{N}, Tuple{cT}, Tuple{T}, Tuple{AbstractVector{<:AbstractArray{cT}}, AbstractVector{<:AbstractMatrix{T}}, NTuple{N, Int64}}} where {T<:Real, cT<:Complex{T}, N}","page":"API","title":"MRFingerprintingRecon.calculateBackProjection","text":"calculateBackProjection(data, trj, img_shape; U, density_compensation, verbose)\ncalculateBackProjection(data, trj, cmaps::AbstractVector{<:AbstractArray{cT,N}}; U, density_compensation, verbose)\ncalculateBackProjection(data, trj, cmaps_img_shape; U, density_compensation, verbose)\ncalculateBackProjection(data, trj, cmaps; U)\n\nCalculate (filtered) backprojection\n\nArguments\n\ndata <: Union{AbstractVector{<:AbstractMatrix{cT}},AbstractMatrix{cT}}: Complex dataset either as AbstractVector of matrices or single matrix. The optional outer matrix defines different time frames that are reconstructed in the subspace defined in U.\ntrj <: AbstractVector{<:AbstractMatrix{T}}: Trajectory with samples corresponding to the dataset. For a Cartesian reconstruction, use T <: Int and define trj[it][idim,ik] ∈ (1, img_shape[idim]). If T <: Float, the NFFT is used.\n\nOne of the following arguments needs to be supplied\n\nimg_shape::NTuple{N,Int}: Shape of image; in this case, the data is reconstructed coilwise.\ncmaps::::AbstractVector{<:AbstractArray{T}}: Coil sensitivities; in this case, the coils are added up to a single backprojection.\n\nOptional Keyword Arguments\n\nU::Matrix = I(length(data)) or = I(1)`: Basis coefficients of subspace (only defined if data and trj have different timeframes)\ndensity_compensation = :none: Values of :radial_3D, :radial_2D, :none, or of type AbstractVector{<:AbstractVector}\nverbose::Boolean = false: Verbosity level\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.calculateGoldenMeans-Tuple{}","page":"API","title":"MRFingerprintingRecon.calculateGoldenMeans","text":"calculateGoldenMeans()\n\nFunction to calculate 3D golden means [1].\n\nReferences\n\n[1] Chan, R.W., Ramsay, E.A., Cunningham, C.H. and Plewes, D.B. (2009), Temporal stability of adaptive 3D radial MRI using multidimensional golden means. Magn. Reson. Med., 61: 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.grog_calib-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.grog_calib","text":"grog_calib(data, trj, Nr)\n\nPerform GROG kernel calibration based on whole radial trajectory and passed data. Calibration follows the work on self-calibrating radial GROG (https://doi.org/10.1002/mrm.21565).\n\nArguments\n\ndata::AbstractVector{<:AbstractMatrix{cT}}: Complex dataset passed as AbstractVector of matrices\ntrj::Vector{Matrix{Float32}}: Trajectory with samples corresponding to the dataset passed as AbstractVector of matrices with Float32 entries\nNr::Int: Number of samples per read out\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.grog_gridding!-NTuple{5, Any}","page":"API","title":"MRFingerprintingRecon.grog_gridding!","text":"grog_gridding!(data, trj, lnG, Nr, img_shape)\n\nPerform gridding of data based on pre-calculated GROG kernel.\n\nArguments\n\ndata::AbstractVector{<:AbstractMatrix{cT}}: Complex dataset passed as AbstractVector of matrices\ntrj::Vector{Matrix{Float32}}: Trajectory with samples corresponding to the dataset passed as AbstractVector of matrices with Float32 entries\nlnG::Vector{Matrix{Float32}}: Natural logarithm of GROG kernel in all dimensions\nNr::Int: Number of samples per read out\nimg_shape::Tuple{Int}: Image dimensions\n\nOutput\n\ntrj::Vector{Matrix{Int32}}: Cartesian trajectory with the elements trj[it][idim,ik] ∈ (1, img_shape[idim])\n\nDimensions:\n\ndata:   [timesteps][samples, spokes, coils, repetitions of sampling pattern]\ntrj:    [timesteps][dims, samples, repetitions]\nlnG:    [dims][Ncoils, Ncoils]\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.kooshball-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.kooshball","text":"kooshball(Nr, theta, phi; thetaRot, phiRot, delay)\n\nFunction to calculate kooshball trajectory.\n\nArguments\n\nNr::Int: Number of read out samples\ntheta::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles theta for each cycle and timestep.\nphi::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles phi for each cycle and timestep.\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float} = (0, 0, 0): Gradient delays in (HF, AP, LR)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.kooshballGA-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.kooshballGA","text":"kooshballGA(Nr, Ncyc, Nt; thetaRot, phiRot, delay)\n\nFunction to calculate  golden means [1] based kooshball trajectory.\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float}= (0, 0, 0): Gradient delays in (HF, AP, LR)\n\nReferences\n\n[1] Chan, R.W., Ramsay, E.A., Cunningham, C.H. and Plewes, D.B. (2009), Temporal stability of adaptive 3D radial MRI using multidimensional golden means. Magn. Reson. Med., 61: 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.radial_grog!-NTuple{4, Any}","page":"API","title":"MRFingerprintingRecon.radial_grog!","text":"radial_grog!(data, trj, Nr, img_shape)\n\nPerform GROG kernel calibration and gridding [1] of data in-place. The trajectory is returned with integer values.\n\nArguments\n\ndata::AbstractVector{<:AbstractMatrix{cT}}: Complex dataset passed as AbstractVector of matrices\ntrj::Vector{Matrix{Float32}}: Trajectory with samples corresponding to the dataset passed as AbstractVector of matrices with Float32 entries\nNr::Int: Number of samples per read out\nimg_shape::Tuple{Int}: Image dimensions\n\nOutput\n\ntrj::Vector{Matrix{Int32}}: Cartesian trajectory with the elements trj[it][idim,ik] ∈ (-img_shape[idim]/2, img_shape[idim]/2-1)\n\nReferences\n\n[1] Seiberlich, N., Breuer, F., Blaimer, M., Jakob, P. and Griswold, M. (2008), Self-calibrating GRAPPA operator gridding for radial and spiral trajectories. Magn. Reson. Med., 59: 930-935. https://doi.org/10.1002/mrm.21565\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_2d_radial_goldenratio-Tuple{Any, Any, Any}","page":"API","title":"MRFingerprintingRecon.traj_2d_radial_goldenratio","text":"traj_2d_radial_goldenratio(Nr, Ncyc, Nt; thetaRot, phiRot, delay, N)\n\nFunction to calculate 2D golden ratio based trajectory [1]. By modifying N also tiny golden angles [2] are supported.\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float} = (0, 0, 0): Gradient delays in (HF, AP, LR)\nN::Int = 1: Number of tiny golden angle\n\nReferences\n\n[1] Winkelmann S, Schaeffter T, Koehler T, Eggers H, Doessel O. An optimal radial profile order based on the Golden Ratio for time-resolved MRI. IEEE TMI 26:68–76 (2007) [2] Wundrak S, Paul J, Ulrici J, Hell E, Geibel MA, Bernhardt P, Rottbauer W, Rasche V. Golden ratio sparse MRI using tiny golden angles. Magn Reson Med 75:2372-2378 (2016)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRFingerprintingRecon.traj_cartesian-NTuple{4, Any}","page":"API","title":"MRFingerprintingRecon.traj_cartesian","text":"traj_cartesian(T, Nx, Ny, Nz, Nt)\n\nGenerate a 3D Cartesian trajectory. As input to functions using NFFTs, the trajectory can be defined as floats ∈ [-0.5, 0.5). For use with Cartesian FFTs, the trajectory consists of integers ∈ [1, N].\n\nArguments\n\nNx::Int: Number of readout samples\nNy::Int: Number of phase encoding lines\nNz::Int: Number of phase encoding lines (third dimension)\nNt::Int: Number of time steps in the trajectory\n\nOptional Keyword Argument\n\nT::Type=Int: Type of output trajectory. If T <: Float, trajectory is defined ∈ (-0.5, 0.5). If T <: Int, trajectory consists of values ∈ (1, N) instead.\n\n\n\n\n\n","category":"method"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"TODO","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"For this example, we need the following packages:","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"using MRFingerprintingRecon\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"build_literate/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#MRFingerprintingRecon.jl","page":"Home","title":"MRFingerprintingRecon.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the MRFingerprintingRecon.jl package. Stay tuned for the documentation...","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation of all exported functions can be found in the API Section.","category":"page"}]
}
