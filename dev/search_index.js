var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRISubspaceRecon.jl package:\n\n","category":"section"},{"location":"api/#MRISubspaceRecon.FFTNormalOp-Tuple{Any, Any, Any}","page":"API","title":"MRISubspaceRecon.FFTNormalOp","text":"FFTNormalOp(img_shape, trj, U; cmaps)\nFFTNormalOp(M, U; cmaps)\nFFTNormalOp(Λ; cmaps, eltype_x)\n\nCreate normal operator of FFT operator. Differentiate between functions exploiting a pre-calculated kernel basis Λ and the functions which calculate Λ based on a passed trajectory trj or mask M.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntraj::Vector{Matrix}: Trajectory\nU::Matrix: Basis coefficients of subspace\ncmaps::Matrix=(1,): Coil sensitivities\nsample_mask::AbstractArray{Bool}=trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are included in the reconstruction\nM::Vector{Matrix}: Mask specific to FFTNormalOp(M, U; cmaps) method. Here, M represents a Cartesian binary mask that indicates in every time frame which phase-encoding lines were acquired. This means, for example, M is sized (Nx, Ny, Nt) for a 2D image. Explicit use of a trajectory with FFTNormalOp(img_shape, trj, U; cmaps) is generally recommended.\nΛ::Array{Complex{T},3}: Toeplitz kernel basis resulting from internal calculate_kernel_cartesian method. \nnum_fft_threads::Int=round(Int, Threads.nthreads()/size(U, 2)) or `round(Int, Threads.nthreads()/size(Λ, 1)): Number of Threads for FFT\neltype_x=eltype(Λ) define the type of x (in the product FFTNormalOp(Λ) * x). The default is the same eltype as Λ\n\nReferences\n\nTamir JI, et al. “T2 shuffling: Sharp, multicontrast, volumetric fast spin-echo imaging”. Magn Reson Med. 77.1 (2017), pp. 180–195. https://doi.org/10.1002/mrm.26102\nAssländer J, et al. “Low rank alternating direction method of multipliers reconstruction for MR fingerprinting”. Magn Reson Med 79.1 (2018), pp. 83–96. https://doi.org/10.1002/mrm.26639\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.NFFTNormalOp-Union{Tuple{Tc}, Tuple{T}, Tuple{Any, AbstractArray{T, 3}, AbstractArray{Tc}}} where {T<:Real, Tc<:Union{Complex{T}, T}}","page":"API","title":"MRISubspaceRecon.NFFTNormalOp","text":"NFFTNormalOp(img_shape, trj, U; cmaps, sample_mask, verbose, num_fft_threads)\nNFFTNormalOp(img_shape, Λ, kmask_indcs; cmaps)\n\nCreate normal operator of NFFT operator. Differentiate between functions exploiting a pre-calculated Toeplitz kernel basis Λ and the function which calculates Λ based on a passed trajectory trj. When the basis functions U are real-valued, a real-only NUFFT is used to compute Λ, reducing the data volume and computation time for the spreading and interpolation steps by half.\n\nArguments\n\nimg_shape::Tuple{Int}: Image dimensions\ntrj::AbstractArray: Trajectory, use CuArray as input type to use CUDA code.\nU::AbstractMatrix: Basis coefficients of subspace\ncmaps::AbstractVector{Matrix}=(1,): Coil sensitivities, use AbstractVector{CuArray} as type for use with CUDA code.\nsample_mask::AbstractArray{Bool} = trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are included in the reconstruction\nverbose::Boolean=false: Verbose level\nnum_fft_threads::Int=round(Int, Threads.nthreads()/size(U, 2)) or round(Int, Threads.nthreads()/size(Λ, 1)): Number of threads for FFT\nΛ: Toeplitz kernel basis resulting from internal calculate_kernel_noncartesian method. Using a real basis U reduces its size by a factor of 2.\n\nReferences\n\nWajer FTAW, and Pruessmann, KP. “Major Speedup of Reconstruction for Sensitivity Encoding with Arbitrary Trajectories”. In: Proc. Intl. Soc. Mag. Reson. Med 9 (2001).\nFessler JA, et al. \"Toeplitz-Based Iterative Image Reconstruction for MRI With Correction for Magnetic Field Inhomogeneity\". IEEE Trans. Signal Process., 53.9 (2006).\nMani M, et al. “Fast iterative algorithm for the reconstruction of multishot non-cartesian diffusion data”. Magn Reson Med. 74.4 (2015), pp. 1086–1094. https://doi.org/10.1002/mrm.25486\nUecker M, Zhang S, and Frahm J. “Nonlinear inverse reconstruction for real-time MRI of the human heart using undersampled radial FLASH\". Magn Res Med. 63 (2010), pp. 1456–1462. https://doi.org/10.1002/mrm.22453\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.calculate_backprojection-Union{Tuple{Tc}, Tuple{T}, Tuple{AbstractArray{Tc, 3}, AbstractArray{T, 3}, Any}} where {T<:Real, Tc<:Complex{T}}","page":"API","title":"MRISubspaceRecon.calculate_backprojection","text":"calculate_backprojection(data, trj, img_shape; U, sample_mask, density_compensation, verbose)\ncalculate_backprojection(data, trj, cmaps::AbstractVector{<:AbstractArray{Tc,N}}; U, sample_mask, density_compensation, verbose)\ncalculate_backprojection(data, trj, img_shape; U, sample_mask, density_compensation, verbose)\ncalculate_backprojection(data, trj, cmaps; U, sample_mask)\n\nCalculate (filtered) backprojection.\n\nArguments\n\ndata <: AbstractArray{Complex}: Complex dataset with axes (samples, time frames, channels). Time frames are reconstructed using the subspace defined in U. Use CuArray as input type to use CUDA GPU code.\ntrj <: AbstractArray: Trajectory with sample coordinates corresponding to the dataset. For a Cartesian reconstruction, use T <: Int and define trj[idim,it,ik] ∈ (1, img_shape[idim]). If T <: Float, the NFFT is used. Use CuArray as input type to use CUDA code.\n\nOne of the following arguments needs to be supplied\n\nimg_shape::NTuple{N,Int}: Shape of output image; in this case, the data is reconstructed per coil.\ncmaps::AbstractVector{<:AbstractArray{Tc}}: Coil sensitivities; when provided, the coils are combined into an array with no coil axis. Use AbstractVector{CuArray{Tc,N}} as type for use with CUDA code.\n\nOptional Keyword Arguments\n\nU::Matrix=I(size(trj)[end]) or =I(1): Basis coefficients of subspace (only defined if data and trj have different timeframes)\nsample_mask::AbstractArray{Bool}=trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are included in the reconstruction\ndensity_compensation=:none: Values of :radial_3D, :radial_2D, :none, or of type AbstractVector{<:AbstractVector}\nverbose::Boolean=false: Verbosity level\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.calculate_coil_maps-Union{Tuple{T}, Tuple{N}, Tuple{AbstractArray{Complex{T}}, AbstractArray{T}, NTuple{N, Int64}}} where {N, T}","page":"API","title":"MRISubspaceRecon.calculate_coil_maps","text":"calculate_coil_maps(data, trj, img_shape; U, density_compensation, kernel_size, calib_size, eigThresh_1, eigThresh_2, nmaps, verbose)\n\nEstimate coil sensitivity maps using ESPIRiT [1].\n\nArguments\n\ndata::AbstractArray: Complex dataset with axes (samples, time frames, channels). Time frames are reconstructed using the subspace defined in U. Use CuArray as input type to use CUDA code.\ntrj::AbstractArray: Trajectory with sample coordinates corresponding to the dataset Use CuArray as input type to use GPU code.\nimg_shape::NTuple{N,Int}: Shape of output image\n\nKeyword Arguments\n\nU::Matrix=ones(size(trj)[end]) : I(1): Basis coefficients of subspace\nsample_mask::AbstractArray{Bool}=trues(size(trj)[2:end]): Mask indicating which acquired k-space samples are included in the reconstruction\ndensity_compensation=:radial_3D: Values of :radial_3D, :radial_2D, :none, or of type  AbstractArray\nkernel_size=ntuple(_ -> 6, N): Kernel size\ncalib_size=ntuple(_ -> 24, N): Size of calibration region\neigThresh_1=0.01: Threshold of first eigenvalue\neigThresh_2=0.9: Threshold of second eigenvalue\nnmaps=1: Number of estimated maps\nNiter_cg: Number of CG iterations used for the reconstruction. The default is 100 and 5 for non-Cartesian and Cartesian trajectories, respectively. Using a number of iterations too large for a given dataset can introduce errors.\nverbose::Boolean=false: Verbosity level\n\nReturn\n\ncmaps::Vector{Array}: Coil sensitivities as Vector of arrays\n\nReferences\n\nUecker M, Lai P, Murphy MJ, Virtue P, Elad M, Pauly JM, Vasanawala SS, and Lustig M. \"ESPIRiT—an eigenvalue approach to autocalibrating parallel MRI: Where SENSE meets GRAPPA\". Magn. Reson. Med. 71 (2014), pp. 990-1001. https://doi.org/10.1002/mrm.24751\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.calculate_golden_means-Tuple{}","page":"API","title":"MRISubspaceRecon.calculate_golden_means","text":"calculate_golden_means()\n\nFunction to calculate the 3D golden means [1].\n\nReferences\n\nChan RW, Ramsay EA, Cunningham CH, and Plewes DB. \"Temporal stability of adaptive 3D radial MRI using multidimensional golden means\". Magn. Reson. Med. (2009), 61: 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.grog_calib-Tuple{Any, Any, Any}","page":"API","title":"MRISubspaceRecon.grog_calib","text":"grog_calib(data, trj, Nr)\n\nPerform GROG kernel calibration based on the radial trajectory and acquired k-space data [1].\n\nArguments\n\ndata::AbstractAbstractArray: Complex dataset with dimensions (samples per time frame [Nr], time frames, Rx channels)\ntrj::AbstractArray: Trajectory with samples corresponding to the dataset, passed as AbstractArray with dimension (dims, samples per time frame, time frames)\nNr::Int: Number of samples per readout\n\nReferences\n\nSeiberlich N, Breuer F, Blaimer M, Jakob P, and Griswold M. \"Self-calibrating GRAPPA operator gridding for radial and spiral trajectories\". Magn. Reson. Med. 59 (2008), pp. 930-935. https://doi.org/10.1002/mrm.21565\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.grog_gridding!-NTuple{5, Any}","page":"API","title":"MRISubspaceRecon.grog_gridding!","text":"grog_gridding!(data, trj, lnG, Nr, img_shape)\n\nPerform gridding of data based on pre-calculated GROG kernel.\n\nArguments\n\ndata::AbstractVector{<:AbstractMatrix}: Complex dataset passed as AbstractVector of matrices\ntrj::AbstractArray}: Trajectory with samples corresponding to the dataset passed as AbstractVector of matrices with Float32 entries\nlnG::AbstractArray{Matrix}: Natural logarithm of GROG kernel in all dimensions\nNr::Int: Number of samples per read out\nimg_shape::Tuple{<:Integer}: Image dimensions\n\nOutput\n\ntrj::AbstractArray{<:Integer}: Cartesian trajectory with the elements trj[idim,ik,it] ∈ (1, img_shape[idim])\n\nDimensions:\n\ndata:   (samples, timesteps, coils, repetitions of sampling pattern)\ntrj:    (dims, samples, timesteps)\nlnG:    (dims][Ncoils, Ncoils)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.radial_grog!-NTuple{4, Any}","page":"API","title":"MRISubspaceRecon.radial_grog!","text":"radial_grog!(data, trj, Nr, img_shape)\n\nPerform GROG kernel calibration and gridding of data in-place [1]. The trajectory is returned with integer values.\n\nArguments\n\ndata::AbstractArray}: Complex dataset with dimensions (samples per time frame [Nr], time frames, Rx channels)\ntrj::AbstractArray: Trajectory with samples corresponding to the dataset, passed as AbstractArray with dimension (dims, samples per time frame, time frames)\nNr::Int: Number of samples per read out\nimg_shape::Tuple{Int}: Image dimensions\n\nOutput\n\ntrj::AbstractArray{<:Integer}}: Cartesian trajectory with the elements trj[idim,ik,it] ∈ (1, img_shape[idim])\n\nReferences\n\nSeiberlich N, Breuer F, Blaimer M, Jakob P, and Griswold M. \"Self-calibrating GRAPPA operator gridding for radial and spiral trajectories\". Magn. Reson. Med. 59 (2008), pp. 930-935. https://doi.org/10.1002/mrm.21565\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.traj_2d_radial_goldenratio-Tuple{Any, Any, Any}","page":"API","title":"MRISubspaceRecon.traj_2d_radial_goldenratio","text":"traj_2d_radial_goldenratio(Nr, Ncyc, Nt; thetaRot, phiRot, delay, N)\n\nFunction to calculate a 2D radial trajectory with golden-angle spacing between subsequent readouts [1]. The use of tiny golden angles [2] is supported by modifying N.\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float} = (0, 0, 0): Gradient delays in (HF, AP, LR)\nN::Int = 1: Number of tiny golden angle\n\nReferences\n\nWinkelmann S, Schaeffter T, Koehler T, Eggers H, Doessel O. \"An optimal radial profile order based on the Golden Ratio for time-resolved MRI\". IEEE TMI 26:68-76 (2007)\nWundrak S, Paul J, Ulrici J, Hell E, Geibel MA, Bernhardt P, Rottbauer W, Rasche V. \"Golden ratio sparse MRI using tiny golden angles\". Magn. Reson. Med. 75:2372-2378 (2016)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.traj_cartesian-NTuple{4, Any}","page":"API","title":"MRISubspaceRecon.traj_cartesian","text":"traj_cartesian(T, Nx, Ny, Nz, Nt)\n\nGenerate a 3D Cartesian trajectory.\n\nArguments\n\nNx::Int: Number of readout samples\nNy::Int: Number of phase encoding lines\nNz::Int: Number of phase encoding lines (third dimension)\nNt::Int: Number of time steps in the trajectory\n\nOptional Keyword Argument\n\nT::Type=Int: Type of output trajectory. If T <: Float, trajectory is defined ∈ (-0.5, 0.5). If T <: Int, trajectory consists of values ∈ (1, N) instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.traj_kooshball-Tuple{Any, Any, Any}","page":"API","title":"MRISubspaceRecon.traj_kooshball","text":"traj_kooshball(Nr, theta, phi; thetaRot, phiRot, delay)\n\nFunction to calculate a 3D radial kooshball trajectory with custom sets of projection angles.\n\nArguments\n\nNr::Int: Number of read out samples\ntheta::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles theta for each cycle and time step.\nphi::Array{Float,2}: Array with dimensions: Ncyc, Nt defining the angles phi for each cycle and time step.\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float} = (0, 0, 0): Gradient delays in (HF, AP, LR)\n\n\n\n\n\n","category":"method"},{"location":"api/#MRISubspaceRecon.traj_kooshball_goldenratio-Tuple{Any, Any, Any}","page":"API","title":"MRISubspaceRecon.traj_kooshball_goldenratio","text":"traj_kooshball_goldenratio(Nr, Ncyc, Nt; thetaRot, phiRot, delay)\n\nFunction to calculate a 3D radial kooshball trajectory with a golden-means angular spacing of k-space readouts [1].\n\nArguments\n\nNr::Int: Number of read out samples\nNcyc::Int: Number of cycles\nNt::Int: Number of time steps in the trajectory\nthetaRot::Float = 0: Fixed rotation angle along theta\nphiRot::Float = 0: Fixed rotation angle along phi\ndelay::Tuple{Float, Float, Float}= (0, 0, 0): Gradient delays in (HF, AP, LR)\n\nReferences\n\nChan RW, Ramsay EA, Cunningham CH, and Plewes DB. \"Temporal stability of adaptive 3D radial MRI using multidimensional golden means\". Magn. Reson. Med. 61 (2009) pp. 354-363. https://doi.org/10.1002/mrm.21837\n\n\n\n\n\n","category":"method"},{"location":"build_literate/tutorial/","page":"Non-Cartesian MRI","title":"Non-Cartesian MRI","text":"(Image: )","category":"section"},{"location":"build_literate/tutorial/#Non-Cartesian-MRI","page":"Non-Cartesian MRI","title":"Non-Cartesian MRI","text":"This example illustrates how to perform an MRI subspace reconstruction from non-Cartesian k-space data. For this example, we need the following packages:\n\nusing MRISubspaceRecon\nusing ImagePhantoms\nusing LinearAlgebra\nusing IterativeSolvers\nusing FFTW\nusing NonuniformFFTs\nusing Plots\nusing Random\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nWe first simulate some data from a Shepp-Logan phantom and generate some coil maps using various phase modulations:\n\nT = Float32\nNx = 32\nNc = 4 # nr of coefficients in the temporal subspace\nNt = 20 # nr of acquired time frames per cycle\nNcyc = 10 # nr of cycles (i.e., repeats of flip angle pattern)\nimg_shape = (Nx, Nx) # 2D image in this example\n\n# create test image\nx = zeros(Complex{T}, Nx, Nx, Nc)\nx[:, :, 1] = transpose(shepp_logan(Nx))\nx[1:end÷2, :, 1] .*= exp(1im * π / 3)\nx[:, :, 2] = shepp_logan(Nx)\n\n# coil maps\nNcoil = 9\ncmaps = ones(Complex{T}, Nx, Nx, Ncoil)\n[cmaps[i, :, 2] .*= exp(1im * π * i / Nx) for i ∈ axes(cmaps, 1)]\n[cmaps[i, :, 3] .*= exp(-1im * π * i / Nx) for i ∈ axes(cmaps, 1)]\n[cmaps[:, i, 4] .*= exp(1im * π * i / Nx) for i ∈ axes(cmaps, 2)]\n[cmaps[:, i, 5] .*= exp(-1im * π * i / Nx) for i ∈ axes(cmaps, 2)]\n[cmaps[i, :, 6] .*= exp(2im * π * i / Nx) for i ∈ axes(cmaps, 1)]\n[cmaps[i, :, 7] .*= exp(-2im * π * i / Nx) for i ∈ axes(cmaps, 1)]\n[cmaps[:, i, 8] .*= exp(2im * π * i / Nx) for i ∈ axes(cmaps, 2)]\n[cmaps[:, i, 9] .*= exp(-2im * π * i / Nx) for i ∈ axes(cmaps, 2)]\n\n# coil maps are defined as vectors of complex n-dimensional arrays\nfor i ∈ CartesianIndices(@view cmaps[:, :, 1])\n    cmaps[i, :] ./= norm(cmaps[i, :])\nend\ncmaps = [cmaps[:, :, ic] for ic = 1:Ncoil]\nnothing #hide\n\nNext, we set up a kooshball trajectory for data acquisition and generate a set of basis functions. The non-Cartesian methods use float trajectories in range k in -05 05), as opposed to integer trajectories for Cartesian methods.\n\n# set up trajectory\nα_g = 2π / (1 + √5)\nphi = Float32.(α_g * (1:Nt*Ncyc))\ntheta = Float32.(0 * (1:Nt*Ncyc) .+ pi / 2)\nphi = reshape(phi, Ncyc, Nt)\ntheta = reshape(theta, Ncyc, Nt)\n\n# generate trj as (2, Nx*Ncyc, Nt)-shaped array\n# alternatively, trj can be shaped as (ndims, n_ADC, n_readouts, n_timeframes)\ntrj = traj_kooshball(2Nx, theta, phi) # shaped (ndims, nsamples, n_timeframes)\ntrj = trj[1:2, :, :] # use only the first 2 dims as a 2D k-space trj\n\n# set up basis functions\nU = randn(Complex{T}, Nt, Nc)\nU, _, _ = svd(U)\nnothing #hide\n\nWe use the phantom image x, the coil maps cmaps, the trajectory trj, and the basis functions U to simulate some k-space data:\n\n# simulate data as (2Nx*Ncyc, Nt, Ncoil)-shaped array\n# alternatively, data can be shaped as (2Nx, Ncyc, Nt, Ncoil)\ndata = Array{Complex{T},3}(undef, 2Nx * Ncyc, Nt, Ncoil)\nnfftplan = PlanNUFFT(Complex{T}, img_shape; fftshift=true)\nxcoil = copy(x)\n\nfor icoil ∈ axes(data, 3)\n    xcoil .= x\n    xcoil .*= cmaps[icoil]\n    for it ∈ axes(data, 2)\n        set_points!(nfftplan, NonuniformFFTs._transform_point_convention.(reshape(trj[:, :, it], 2, :)))\n        xt = reshape(reshape(xcoil, :, Nc) * U[it, :], Nx, Nx)\n        # simulate data from image using type-2 (uniform to non-uniform) NUFFT\n        @views NonuniformFFTs.exec_type2!(data[:, it, icoil], nfftplan, xt)\n    end\nend\n\nThe data format uses either 3D or 4D arrays, where the 4D format is used to place ADC points within a separate array axis from the total number of samples. Internally, all code relies on 3D arrays and the 4D arrays are handled by wrappers. Furthermore, reconstructions can make use of a binary mask to exclude specific samples from being included in the reconstruction. To illustrate the data removal, we create a mask that removes one time frame from one cycle:\n\n# create sampling mask\nit_rm = 1\nicyc_rm = 5\nsample_mask = trues(2Nx, Ncyc, Nt)\nsample_mask[:, icyc_rm, it_rm] .= false\nsample_mask = reshape(sample_mask, 2Nx*Ncyc, Nt) # masks are 2- or 3-dim depending on format of trj and data\nnothing #hide\n\nCoil maps may also be auto-calibrated from k-space measurements using ESPIRiT:\n\ncmaps = calculate_coil_maps(data, trj, img_shape; U)\nnothing #hide\n\nNow, we can compute the normal operator and the adjoint NUFFT (backprojection) with the specified sampling mask:\n\nAᴴA = NFFTNormalOp(img_shape, trj, U; cmaps, sample_mask)\nb = calculate_backprojection(data, trj, cmaps; U, sample_mask)\nnothing #hide\n\nGPU-methods are called through multiple dispatch, i.e., when objects of type CuArray are passed as arguments. The normal operator A and the backprojection b are compatible with the iterative solvers from IterativeSolvers.jl and RegularizedLeastSquares.jl. This enables solving the inverse problem with various algorithms, including conjugate gradient (CG):\n\n# solve inverse problem with CG\nxr = cg(AᴴA, vec(b), maxiter=20)\nxr = reshape(xr, Nx, Nx, Nc) # reshape vector back to 2D image with Nc coefficients\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#MRISubspaceRecon.jl","page":"Home","title":"MRISubspaceRecon.jl","text":"MRISubspaceRecon.jl package package aims to enable rapid iterative reconstruction of Cartesian and non-Cartesian MRI data using subspace modeling [1,2]. Particular care is given to enable the reconstruction of large numbers of subspace coefficients along with large image grid sizes.\n\nFor compatibility with other Julia packages, such as IterativeSolvers.jl and RegularizedLeastSquares.jl, operations are defined in terms of linear operators and their effects on the data vectors. MRISubspaceRecon.jl is designed to compute these objects with multi-threaded CPUs and on NVIDIA GPUs. The package further contains functions to perform GRAPPA operator gridding (GROG) [3] or to generate radial trajectories. However, all methods that require an explicit k-space trajectory as input generalize to arbitrary trajectories.\n\nThe documentation of all exported functions can be found in the API Section.","category":"section"},{"location":"#Background","page":"Home","title":"Background","text":"A general (non-Cartesian) subspace reconstruction of coefficient images hatbmx_c from k-space data bmy can be formulated as:\n\nhatbmx_c = undersetbmx_ctextarg min lVert mathbfGFSU_Rbmx_c-bmy rVert_2^2 \nequiv undersetbmx_ctextarg min lVert mathbfAbmx_c-bmy rVert_2^2\n\nwhere mathbfF and mathbfG are block-diagonal Fourier and gridding matrices. mathbfA and mathbfS represent the forward operator (or system matrix) and coil sensitivity profiles, respectively. mathbfU_R is a block matrix composed of R temporal basis functions; its adjoint mathbfU_R^H projects the time series of images onto the basis: bmx_c = mathbfU_R^Hbmx_t, where bmx_t denotes the complete time series of images. \n\nTo decrease computation time, iterative reconstructions employ Toeplitz embedding to avoid repeated gridding operations of non-Cartesian data [4,5,6]. This means that the normal operator mathbfA^HmathbfA  is implemented as a pointwise multiplication at the cost of an oversampling factor of 2 across each spatial dimension. The resulting operator is an Rtimes R matrix per k-space sample and thus has a large total size of 8N_xN_yN_zR^2 for a 3D image. We exploit several methods throughout to handle the large memory requirement, especially when using a GPU for reconstruction. A main point for users is that a real-valued basis mathbfU_R reduces the memory requirement for storing the normal operator by a factor of 2.","category":"section"},{"location":"#CPU-or-GPU","page":"Home","title":"CPU or GPU","text":"Reconstructions of non-Cartesian MRI in MRISubspaceRecon.jl are implemented for CPU and NVIDIA GPUs. The GPU code is included as a Julia extension and is loaded after importing CUDA.jl via:\n\nusing MRISubspaceRecon\nusing CUDA\n\nWe recommend using the GPU code which can be faster by a factor of 10–20 than CPU multi-threading (for typical solvers like conjugate gradient or FISTA [7]). However, a specific GPU implementation for Cartesian MRI is still under development. In this case, one can use the CPU implementation or the non-Cartesian methods.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"Assländer J, et al. “Low rank alternating direction method of multipliers reconstruction for MR fingerprinting”. Magn Reson Med 79.1 (2018), pp. 83–96. https://doi.org/10.1002/mrm.26639\nTamir JI, et al. “T2 shuffling: Sharp, multicontrast, volumetric fast spin-echo imaging”. Magn Reson Med. 77.1 (2017), pp. 180–195. https://doi.org/10.1002/mrm.26102\nSeiberlich N, Breuer F, Blaimer M, Jakob P, and Griswold M. \"Self-calibrating GRAPPA operator gridding for radial and spiral trajectories\". Magn. Reson. Med. 59 (2008), pp. 930-935. https://doi.org/10.1002/mrm.21565\nFTAW Wajer and KP Pruessmann. “Major Speedup of Reconstruction for Sensitivity Encoding with Arbitrary Trajectories”. In: Proc. Intl. Soc. Mag. Reson. Med 9 (2001)\nM Uecker, S Zhang, and J Frahm. “Nonlinear inverse reconstruction for real-time MRI of the human heart using undersampled radial FLASH”. In: Magnetic Resonance in Medicine 63.6 (2010), pp. 1456–1462. doi: 10.1002/mrm.22453.\nM Mani et al. “Fast iterative algorithm for the reconstruction of multishot non-cartesian diffusion data” In: Magnetic Resonance in Medicine 74.4 (2015), pp. 1086–1094. doi: 10.1002/mrm.25486.\nA Beck and M Teboulle. “A Fast Iterative Shrinkage-Thresholding Algorithm for Linear Inverse Problems”. In: SIAM Journal on Imaging Sciences 2.1 (2009), pp. 183–202. doi: 10.1137/080716542.","category":"section"}]
}
